import { PayloadAction, createSlice, nanoid } from "@reduxjs/toolkit";

//NOTE The types for initial state where generated by Github AI cool!
type User = {
  image: {
    png: string;
    webp: string;
  };
  username: string;
};

export type Reply = {
  id: number | string;
  content: string;
  createdAt: string;
  score: number;
  hasUpVoted: false;
  hasDownVoted: false;
  replyingTo: string;
  user: User;
  replies: Reply[];
  isNewComment: boolean;
};

export type Comment = {
  id: number | string;
  content: string;
  createdAt: string;
  score: number;
  hasUpVoted: boolean;
  hasDownVoted: boolean;
  user: User;
  replies: Reply[];
  isNewComment: boolean;
};

type State = {
  currentUser: User;
  comments: Comment[];
};

type VotePayload = {
  commentId: number | string;
};

type AddCommentPayload = {
  commentId: number | string;
  content: string;
};

//NOTE Simulate the API call
const initialState: State = {
  currentUser: {
    image: {
      png: "./images/avatars/image-juliusomo.png",
      webp: "./images/avatars/image-juliusomo.webp",
    },
    username: "juliusomo",
  },
  comments: [
    {
      id: 1,
      content:
        "Impressive! Though it seems the drag feature could be improved. But overall it looks incredible. You've nailed the design and the responsiveness at various breakpoints works really well.",
      createdAt: "1 month ago",
      score: 12,
      hasUpVoted: false,
      hasDownVoted: false,
      user: {
        image: {
          png: "image-amyrobson.png",
          webp: "./images/avatars/image-amyrobson.webp",
        },
        username: "amyrobson",
      },
      replies: [],
      isNewComment: false,
    },
    {
      id: 2,
      content:
        "Woah, your project looks awesome! How long have you been coding for? I'm still new, but think I want to dive into React as well soon. Perhaps you can give me an insight on where I can learn React? Thanks!",
      createdAt: "2 weeks ago",
      score: 5,
      hasUpVoted: false,
      hasDownVoted: false,
      user: {
        image: {
          png: "image-maxblagun.png",
          webp: "./images/avatars/image-maxblagun.webp",
        },
        username: "maxblagun",
      },
      replies: [
        {
          id: 3,
          content:
            "If you're still new, I'd recommend focusing on the fundamentals of HTML, CSS, and JS before considering React. It's very tempting to jump ahead but lay a solid foundation first.",
          createdAt: "1 week ago",
          score: 4,
          hasUpVoted: false,
          hasDownVoted: false,
          replyingTo: "maxblagun",
          user: {
            image: {
              png: "image-ramsesmiron.png",
              webp: "./images/avatars/image-ramsesmiron.webp",
            },
            username: "ramsesmiron",
          },
          replies: [],
          isNewComment: false,
        },
        {
          id: 4,
          content:
            "I couldn't agree more with this. Everything moves so fast and it always seems like everyone knows the newest library/framework. But the fundamentals are what stay constant.",
          createdAt: "2 days ago",
          score: 2,
          hasUpVoted: false,
          hasDownVoted: false,
          replyingTo: "ramsesmiron",
          user: {
            image: {
              png: "image-juliusomo.png",
              webp: "./images/avatars/image-juliusomo.webp",
            },
            username: "juliusomo",
          },
          replies: [],
          isNewComment: false,
        },
      ],
      isNewComment: false,
    },
  ],
};

const handleCommentVote = (
  comment: Comment | Reply,
  isUpVoted: boolean
): Partial<Comment> | Reply => {
  //Partial fixes the type error related to "replies" prop
  return {
    ...comment,
    hasUpVoted: isUpVoted,
    hasDownVoted: !isUpVoted,
    score: isUpVoted ? comment.score + 1 : comment.score - 1,
  };
};

//Crawl through the comments and replies to find the matching commentId and update accordingly
const handleCommentVoteAction = (
  comments: Comment[],
  targetCommentId: number | string,
  isUpVoted: boolean
) => {
  let hasFoundMatch = false;

  return comments.map((comment) => {
    //Since we cannot break .map. If already found a match just return current comment
    if (hasFoundMatch) return comment;
    //Check "parent comment" for matching commentId
    if (comment.id === targetCommentId) {
      hasFoundMatch = true;
      return handleCommentVote(comment, isUpVoted) as Comment;
    }

    //Check "parent comment" replies for matching commentId
    if (comment.replies?.length) {
      //Check replies for matching commentId
      comment.replies = comment.replies.map((reply) => {
        if (reply.id === targetCommentId) {
          hasFoundMatch = true;
          return handleCommentVote(reply, isUpVoted) as Reply;
        }
        return reply;
      });
    }

    return comment;
  });
};

const handleCommentReply = (content: string, currentUser: User): Reply => {
  return {
    id: nanoid(), //we use random  ID generator from toolkit
    content: content,
    createdAt: "This should be coming from the server",
    score: 0,
    hasUpVoted: false,
    hasDownVoted: false,
    replyingTo: "todo get what user is replying to",
    user: currentUser,
    replies: [],
    isNewComment: content.trim().length === 0,
  };
};

const handleCommentReplyAction = (
  comments: Comment[],
  targetCommentId: number | string,
  content: string,
  currentUser: User
): Comment[] => {
  let hasFoundMatch = false;

  return comments.map((comment) => {
    //Since we cannot break .map. If already found a match just return current comment
    if (hasFoundMatch) return comment;
    //Check "parent comment" for matching commentId
    if (comment.id === targetCommentId) {
      hasFoundMatch = true;
      comment.replies.push(handleCommentReply(content, currentUser));
    }

    //Check "parent comment" replies for matching commentId
    if (comment.replies?.length) {
      //Check replies for matching commentId
      comment.replies = comment.replies.map((reply) => {
        if (reply.id === targetCommentId) {
          hasFoundMatch = true;
          reply.replies.push(handleCommentReply(content, currentUser));
        }
        return reply;
      });
    }

    return comment;
  });
};

//TODO type the action payload
export const commentSlice = createSlice({
  name: "comments",
  initialState,
  reducers: {
    upVoteComment: (state, action: PayloadAction<VotePayload>) => {
      const { comments } = state;
      const { commentId } = action.payload;

      state.comments = handleCommentVoteAction(comments, commentId, true);

      return state;
    },
    downVoteComment: (state, action: PayloadAction<VotePayload>) => {
      const { comments } = state;
      const { commentId } = action.payload;

      state.comments = handleCommentVoteAction(comments, commentId, false);

      return state;
    },
    prepareNewComment: (state, action) => {
      const { comments, currentUser } = state;
      const { commentId } = action.payload;
      console.log("id >>>", commentId);
      state.comments = handleCommentReplyAction(
        comments,
        commentId,
        "",
        currentUser
      );

      return state;
    },
    addComment: (state, action: PayloadAction<AddCommentPayload>) => {
      const { comments, currentUser } = state;
      const { commentId, content } = action.payload;

      state.comments = handleCommentReplyAction(
        comments,
        commentId,
        content,
        currentUser
      );

      return state;
    },
  },
});

export const { upVoteComment, downVoteComment, prepareNewComment } =
  commentSlice.actions;

export const selectCommentReducer = commentSlice.reducer;
